---
layout: post
title: "MySQL高级使用和特性"
description: ""
category: 
tags: [MySQL]
---
{% include JB/setup %}

---

# MySQL体系结构

## 什么是体系结构？

## MySQL部件包括哪些？

* 连接池组件
* 管理服务和工具组件
* SQL接口组件
* 查询分析器组件
* 优化器组件
* 缓冲（Cache）组件
* 插件式存储引擎
* 物理文件

## 各个部件之间的执行顺序是什么？

---

# MySQL存储引擎

## MySQL常见的存储引擎有哪些？

* innodb存储引擎：面向oltp(online transaction processing)、行锁、支持外键、非锁定读、默认采用repeaable级别（可重复读）通过next-keylocking策略避免幻读、插入缓冲、二次写、自适应哈希索引、预读
* myisam存储引擎：不支持事务、表锁、全文索引、适合olap（在线分析处理），其中myd:放数据文件，myi:放索引文件
* ndb存储引擎：集群存储引擎，share nothing，可提高可用性
* memory存储引擎：数据存放在内存中，表锁，并发性能差，默认使用哈希索引
* archive存储引擎：只支持insert和select zlib算法压缩1：10，适合存储归档数据如日志等、行锁
* maria存储引擎：目的取代myisam、缓存数据和索引、行锁、mvcc

## MyISAM和InnoDB有什么不同？如何选择存储引擎？

**MySQL存储引擎MyISAM与InnoDB的优劣**

×         |MyISAM         |InnoDB
:---------|:--------------|:-----------------
存储结构  |每张表被存放在三个文件：frm-表格定义MYD(MYData)-数据文件MYI(MYIndex)-索引文件 | 所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB
存储空间  |MyISAM可被压缩，存储空间较小  |InnoDB的表需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引
可移植性、备份及恢复  | 由于MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作 | 免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了
事务安全  | 不支持  | 每次查询具有原子性 支持 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表
AUTO_INCREMENT    | MyISAM表可以和其他字段一起建立联合索引  | InnoDB中必须包含只有该字段的索引
SELECT  | MyISAM更优 |
INSERT  | |InnoDB更优 |
UPDATE  | |InnoDB更优 |
DELETE  | |InnoDB更优 它不会重新建立表，而是一行一行的删除
COUNT without WHERE | MyISAM更优。因为MyISAM保存了表的具体行数  | InnoDB没有保存表的具体行数，需要逐行扫描统计，就很慢了
COUNT with WHERE  | 一样  | 一样，InnoDB也会锁表
锁  | 只支持表锁  | 支持表锁、行锁 行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的
外键 | 不支持  | 支持
FULLTEXT全文索引  | 支持  | 不支持 可以通过使用Sphinx从InnoDB中获得全文索引，会慢一点

**InnoDB 还是 MyISAM?**

* 你的数据库有外键吗？
* 你需要事务支持吗？
* 你需要全文索引吗？
* 你经常使用什么样的查询模式？
* 你的数据有多大？

> 如果你需要事务处理或是外键，那么InnoDB 可能是比较好的方式。如果你需要全文索引，那么通常来说 MyISAM是好的选择，因为这是系统内建的，然而，我们其实并不会经常地去测试两百万行记录。所以，就算是慢一点，我们可以通过使用Sphinx从InnoDB中获得全文索引。

> 数据的大小，是一个影响你选择什么样存储引擎的重要因素，大尺寸的数据集趋向于选择InnoDB方式，因为其支持事务处理和故障恢复。数据库的在小决定了故障恢复的时间长短，InnoDB可以利用事务日志进行数据恢复，这会比较快。而MyISAM可能会需要几个小时甚至几天来干这些事，InnoDB只需要几分钟。

> 操作数据库表的习惯可能也会是一个对性能影响很大的因素。比如： COUNT() 在 MyISAM 表中会非常快，而在InnoDB 表下可能会很痛苦。而主键查询则在InnoDB下会相当相当的快，但需要小心的是如果我们的主键太长了也会导致性能问题。大批的inserts 语句在MyISAM下会快一些，但是updates 在InnoDB 下会更快一些——尤其在并发量大的时候。

> 根据经验来看，如果是一些小型的应用或项目，那么MyISAM 也许会更适合。当然，在大型的环境下使用MyISAM 也会有很大成功的时候，但却不总是这样的。如果你正在计划使用一个超大数据量的项目，而且需要事务处理或外键支持，那么你真的应该直接使用InnoDB方式。但需要记住InnoDB 的表需要更多的内存和存储，转换100GB 的MyISAM 表到InnoDB 表可能会让你有非常坏的体验。

## 存储时间类型字段用int还是datetime类型？为什么？

**int** 

1. 占用4个字节
2. 建立索引之后，查询速度快
3. 条件范围搜索可以使用使用between
4. 不能使用mysql提供的时间函数

结论：适合需要进行大量时间范围查询的数据表

**datetime**

1. 占用8个字节
2. 允许为空值，可以自定义值，系统不会自动修改其值。
3. 实际格式储存（Just stores what you have stored and retrieves the same thing which you have stored.）
4. 与时区无关（It has nothing to deal with the TIMEZONE and Conversion.）
5. 不可以设定默认值，所以在不允许为空值的情况下，必须手动指定datetime字段的值才可以成功插入数据。
6. 可以在指定datetime字段的值的时候使用now()变量来自动插入系统的当前时间。

结论：datetime类型适合用来记录数据的原始的创建时间，因为无论你怎么更改记录中其他字段的值，datetime字段的值都不会改变，除非你手动更改它。

**timestamp**

1. 占用4个字节
2. 允许为空值，但是不可以自定义值，所以为空值时没有任何意义。
3. TIMESTAMP值不能早于1970或晚于2037。这说明一个日期，例如'1968-01-01'，虽然对于DATETIME或DATE值是有效的，但对于TIMESTAMP值却无效，如果分配给这样一个对象将被转换为0。
4.值以UTC格式保存（ it stores the number of milliseconds）
5.时区转化 ，存储时对当前的时区进行转换，检索时再转换回当前的时区。
6. 默认值为CURRENT_TIMESTAMP()，其实也就是当前的系统时间。
7. 数据库会自动修改其值，所以在插入记录时不需要指定timestamp字段的名称和timestamp字段的值，你只需要在设计表的时候添加一个timestamp字段即可，插入后该字段的值会自动变为当前系统时间。
8. 以后任何时间修改表中的记录时，对应记录的timestamp值会自动被更新为当前的系统时间。

结论：timestamp类型适合用来记录数据的最后修改时间，因为只要你更改了记录中其他字段的值，timestamp字段的值都会被自动更新。

## 如果是字符串类型，字段选char好还是选varchar好？为什么？

> CHAR和VARCHAR类型声明的长度表示你想要保存的最大字符数。

* CHAR列的长度固定为创建表时声明的长度。长度可以为从0到255的任何值。当保存CHAR值时，在它们的右边填充空格以达到指定的长度。当检索到CHAR值时，尾部的空格被删除掉。在存储或检索过程中不进行大小写转换。
* VARCHAR列中的值为可变长字符串。长度可以指定为0到65,535之间的值。(VARCHAR的最大有效长度由最大行大小和使用的字符集确定。整体最大长度是65,532字节）。
同CHAR对比，VARCHAR值保存时只保存需要的字符数，另加一个字节来记录长度(如果列声明的长度超过255，则使用两个字节)。
* VARCHAR值保存时不进行填充。当值保存和检索时尾部的空格仍保留，符合标准SQL。
如果分配给CHAR或VARCHAR列的值超过列的最大长度，则对值进行裁剪以使其适合。如果被裁掉的字符不是空格，则会产生一条警告。如果裁剪非空格字符，则会造成错误(而不是警告)并通过使用严格SQL模式禁用值的插入。参见5.3.2节，“SQL服务器模式”。

## 枚举类型应用在什么场景下？有什么缺陷？

**布尔类型**

MySQL数据库产品没有真正实现对布尔类型的支持，建议大家不要使用MySQL布尔类型BOOL或布尔类型BOOLEAN，而是使用数据库类型微整型TINYINT替代。

**枚举类型**

* MySQL枚举类型的枚举元素允许最大65535个
* 引入枚举类型数据存储，有利于缩减数据库存储数据的容量，尤其能达到减少数据库瓶颈最大的物理IO，逻辑IO也能减小，提高主机的处理能力；
* 引入枚举类型数据存储，有利于简化工程师的代码复杂度、工作量，增加代码的可读性和可维护性；
* 可以通过枚举类型元素值访问数据，也可以根据枚举类型元素编号进行访问数据；

缺点：

* MySQL数据库枚举类型的引入，可能给软件程序的版本发布，存在遗忘数据库结构变更的隐患；
* MySQL数据库枚举类型字段的元素增加，必须以尾部追加的方式，否则影响数据库提供数据服务；
* 枚举类型字段不再需要的元素，也不能进行删除，否则影响数据库提供数据服务；
* MySQL数据库枚举类型的字段定义属性元素值，不能随意调整其顺序，否则影响数据库提供数据服务；

> MySQL数据库枚举类型是一种有应用场景广泛的数据类型，若是抛开网站程序或软件版本发布，可能会导致开发工程师与数据库维护人员之间没有配合好的问题，非常推荐大家把枚举类型引入到生产环境的数据库应用中，对企业而言也可以起到节省人力、物理等成本。建议大家使用枚举类型的时候，尽量把可能需要用到的枚举元素，都写到MySQL数据库表字段的定义属性中，减少出现漏做DDL变更的故障。

**集合类型**

* 数据库的数据存储容量相应缩小，利于减少数据操纵的逻辑IO和物理IO；
* 集合类型的数据读取方便，可根据字符串值，也可以根据字符串集合的顺序编号；
* 集合类型字段的定义属性维护与其他数据类型类似，并不特殊化；
* 开发工程师，不需要借助额外的集合元素编码表或程序中使用编号替代集合的字符串元素，达到减少开发成本、提高代码的可读性和可维护性；

缺点：

* 集合类型字段的集合元素限制最大为64个；
* 集合类型字段的定义属性的集合元素，删除导致锁表而影响数据服务提供；
* 集合类型字段的定义属性的集合元素增加，只能以尾部追加的方式，若是此特性没有掌握，则会导致数据服务提供受影响；

人才招聘网站的用户，设置工作意向城市一项，则往往会选择1-3个城市，甚至更多城市，采用集合类型字段作为数据存储结果的话，将可以大量简化程序复杂度，以及大规模降低数据存储的容量，唯一的遗憾则是集合元素限制为64个，会导致无法满足招聘网站后期业务发展需要。

## 表锁和行锁的优缺点？

MySQL有三种锁的级别：页级、表级、行级。

* MyISAM和MEMORY存储引擎采用的是表级锁（table-level locking）；
* BDB存储引擎采用的是页面锁（page-level locking），但也支持表级锁；
* InnoDB存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁。

* 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。
* 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。
* 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。

MySQL的表级锁有两种模式：表共享读锁（Table Read Lock）和表独占写锁（Table Write
Lock）。MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁。
所以对MyISAM表进行操作，会有以下情况：

* 对MyISAM表的读操作（加读锁），不会阻塞其他进程对同一表的读请求，但会阻塞对同一表的写请求。只有当读锁释放后，才会执行其它进程的写操作。
* 对MyISAM表的写操作（加写锁），会阻塞其他进程对同一表的读和写操作，只有当写锁释放后，才会执行其它进程的读写操作。

原则上数据表有一个读锁时，其它进程无法对此表进行更新操作，但在一定条件下，MyISAM表也支持读取和插入操作的并发进行。MyISAM存储引擎有一个系统变量concurrent_insert，专门用以控制其并发插入的行为，其值分别可以为0、1或2

* 当concurrent_insert设置为0时，不允许并发插入。
* 当concurrent_insert设置为1时，如果MyISAM表中没有空洞（即表的中间没有被删除的行），MyISAM允许在一个进程读表的同时，另一个进程从表尾插入记录。这也是MySQL的默认设置。
* 当concurrent_insert设置为2时，无论MyISAM表中有没有空洞，都允许在表尾并发插入记录。

由于MySQL认为写请求一般比读请求要重要，所以如果有读写请求同时进行的话，MYSQL将会优先执行写操作。这样MyISAM表在进行大量的更新操作时（特别是更新的字段中存在索引的情况下），会造成查询操作很难获得读锁，从而导致查询阻塞。

* 通过指定启动参数low-priority-updates，使MyISAM引擎默认给予读请求以优先的权利。
* 通过执行命令SET LOW_PRIORITY_UPDATES=1，使该连接发出的更新请求优先级降低。
* 通过指定INSERT、UPDATE、DELETE语句的LOW_PRIORITY属性，降低该语句的优先级。

## 当数据库的表有锁的时候，此时有插入数据的操作，是直接插入还是等待解锁后插入？

## 事务一般应用在哪些场景下？

* 原子性，是一个不可分割的逻辑单元，一组sql语句，要么都执行，要么都不执行。
* 隔离性，事务中的执行过程是不可见的。
* 持久性，事务一旦提交，就不可撤销。
* 一致性，事务在发生之前和发生之后，数据是一致。(能量守恒)

## PHP如何调用MySQL的事务？

## 如果事务出现脏读或者幻读，如何解决？

MySQL InnoDB事务的隔离级别有四级，默认是“可重复读”（REPEATABLE READ）。

* 未提交读（READUNCOMMITTED）。另一个事务修改了数据，但尚未提交，而本事务中的SELECT会读到这些未被提交的数据（脏读）。
* 提交读（READCOMMITTED）。本事务读取到的是最新的数据（其他事务提交后的）。问题是，在同一个事务里，前后两次相同的SELECT会读到不同的结果（不重复读）。
* 可重复读（REPEATABLEREAD）。在同一个事务里，SELECT的结果是事务开始时时间点的状态，因此，同样的SELECT操作读到的结果会是一致的。但是，会有幻读现象（稍后解释）。
* 串行化（SERIALIZABLE）。读操作会隐式获取共享锁，可以保证不同事务间的互斥。

四个级别逐渐增强，每个级别解决一个问题。

* 脏读 最容易理解。另一个事务修改了数据，但尚未提交，而本事务中的SELECT会读到这些未被提交的数据。
* 不重复读。解决了脏读后，会遇到，同一个事务执行过程中，另外一个事务提交了新数据，因此本事务先后两次读到的数据结果会不一致。
* 幻读 解决了不重复读，保证了同一个事务里，查询的结果都是事务开始时的状态（一致性）。但是，如果另一个事务同时提交了新数据，本事务再更新时，就会“惊奇的”发现了这些新数据，貌似之前读到的数据是“鬼影”一样的幻觉。

---


# 参考

[MySQL DATETIME vs TIMESTAMP vs INT performance and benchmarking with MyISAM](http://gpshumano.blogs.dri.pt/2009/07/06/mysql-datetime-vs-timestamp-vs-int-performance-and-benchmarking-with-myisam/)\\
[MySQL DATETIME vs TIMESTAMP vs INT performance and benchmarking with InnoDB](http://gpshumano.blogs.dri.pt/2009/07/06/mysql-datetime-vs-timestamp-vs-int-performance-and-benchmarking-with-innodb/)\\
[MySQL: InnoDB 还是 MyISAM?](http://coolshell.cn/articles/652.html)\\
[MySQL数据库之布尔类型、枚举类型和集合类型的应用场景详解](http://www.zhdba.com/mysqlops/2012/03/21/mysql-data-type-set-enum-bool/)\\
[MySQL行锁深入研究](http://www.searchtb.com/2010/09/mysql%E8%A1%8C%E9%94%81%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6-2.html)\\
[MYSQL数据丢失讨论](http://www.woqutech.com/?p=769)\\
[MySQL InnoDB四个事务级别 与 脏读、不重复读、幻读](http://blog.csdn.net/seven_3306/article/details/27085275)\\
