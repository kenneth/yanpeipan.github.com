---
layout: post
title: "程序员面试金典"
description: ""
category: 
tags: []
---
{% include JB/setup %}

# 面试考题

1. 数据结构
* 数组与字符串
* 链表
* 栈与队列
* 树与图
2. 概念与算法
* 位操作
* 智力题
* 数学与概率
* 面向对象设计
* 递归和动态规划
* 扩展性与存储限制
* 排序与查找
* 测试
3. 知识类问题
* C和C++
* Java
* 数据库
* 线程与锁
4. 附加面试题
* 中等难度
* 高等难度

## 数组与字符串

数组问题与字符串问题往往是相通的。换句话说, 书中提到的数组问题也可能以字符串的形式出现，反之亦然。

### 哈希表
散列表（Hash table，也叫哈希表），是根据关键字（Key-value）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。

1. 链式哈希表
* 将数据存储在"桶"(bucket)中, 每个"桶"都是一个链表, 且链表的容量随着冲突的增加而增大.  
2. 开地址哈希表
* 将数据存储在表本身, 并通过各种探查方法来避免冲突问题.  
3. 用二叉查找树实现哈希表
* 搜索、插入、删除的复杂度等于树高, 期望O(log n),最坏O(n)（数列有序，树退化成线性表）.通常采取二叉链表作为二叉查找树的存储结构.
* 虽然二叉查找树的最坏效率是O(n),但它支持动态查询，且有很多改进版的二叉查找树可以使树高为O(log n),如SBT,AVL树，红黑树等。
4. 哈希函数


* 广泛运用DJBX33A (Daniel J. Bernstein, Times 33 with Addition)

    uint32_t time33(char const *str, int len) 
    { 
        unsigned long  hash = 0; 
        for (int i = 0; i < len; i++) { 
            hash = hash *33 + (unsigned long) str[i]; 
        } 
        return hash; 
    }

* 另一个哈希函数, 改编自:<Compilers: Principles, Techniques, and Tools>

    unsigned int hashpjw(const void *key) {
      const char *ptr;
      unsigned int val;
    
      // Hash the key by performing a number of bit operations on it
      val = 0;
      ptr = key;
      while (*ptr != '\0') {
        unsigned int tmp;
        val = (val << 4) + (*ptr);
    
        if ((tmp = (val & 0xf0000000))) {
          val = val ^ (tmp >> 24);
          val = val ^ tmp;
        }
    
        ptr++;
      }
    
      // in practice , replace PRIME_TBLESIZ with the actual table size
      return val % PRIME_TBLESIZ;
    }

