---
layout: post
title: "程序员面试金典"
description: ""
category: 
tags: []
---
{% include JB/setup %}

# 面试考题

1. 数据结构
* 数组与字符串
* 链表
* 栈与队列
* 树与图
2. 概念与算法
* 位操作
* 智力题
* 数学与概率
* 面向对象设计
* 递归和动态规划
* 扩展性与存储限制
* 排序与查找
* 测试
3. 知识类问题
* C和C++
* Java
* 数据库
* 线程与锁
4. 附加面试题
* 中等难度
* 高等难度

## 数组与字符串

数组问题与字符串问题往往是相通的。换句话说, 书中提到的数组问题也可能以字符串的形式出现，反之亦然。

### 哈希表
散列表（Hash table，也叫哈希表），是根据关键字（Key-value）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。

1. 链式哈希表
* 将数据存储在"桶"(bucket)中, 每个"桶"都是一个链表, 且链表的容量随着冲突的增加而增大.  
2. 开地址哈希表
* 将数据存储在表本身, 并通过各种探查方法来避免冲突问题.  
3. 用二叉查找树实现哈希表
* 搜索、插入、删除的复杂度等于树高, 期望O(log n),最坏O(n)（数列有序，树退化成线性表）.通常采取二叉链表作为二叉查找树的存储结构.
* 虽然二叉查找树的最坏效率是O(n),但它支持动态查询，且有很多改进版的二叉查找树可以使树高为O(log n),如SBT,AVL树，红黑树等。
4. 哈希函数


* 广泛运用DJBX33A (Daniel J. Bernstein, Times 33 with Addition)
    
        uint32_t time33(char const *str, int len) 
        {
            unsigned long  hash = 0; 
            for (int i = 0; i < len; i++) {
                    hash = hash *33 + (unsigned long) str[i]; 
            } 
            return hash; 
        }
        

* 另一个哈希函数, 改编自:<Compilers: Principles, Techniques, and Tools>

        unsigned int hashpjw(const void *key) {
          const char *ptr;
          unsigned int val;
        
          // Hash the key by performing a number of bit operations on it
          val = 0;
          ptr = key;
          while (*ptr != '\0') {
            unsigned int tmp;
            val = (val << 4) + (*ptr);
        
            if ((tmp = (val & 0xf0000000))) {
              val = val ^ (tmp >> 24);
              val = val ^ tmp;
            }
        
            ptr++;
          }
        
          // in practice , replace PRIME_TBLESIZ with the actual table size
          return val % PRIME_TBLESIZ;
        }

### ArrayList(动态数组)

按需动态调整大小的数组, 数据访问时间为O(1).

### StringBuffer

创建一个足以容纳所有字符串的数组, 等它拼接完成才将这些字符串转成一个字符串.

### 面试题目

1. 实现一个算法, 确定一个字符串的所有字符是否全都不同.即使不允许使用额外的数据结构,又该如何处理?
2. 用C或C++实现void reverse( char* str)函数, 即反转一个null结尾的字符.
3. 给定两个字符串, 请编写程序, 确定其中一个字符串的字符重新排列后,能否变成另一个字符串.
4. 编写一个方法, 将字符串中的空格全部替换为“% 20”。假定该字符串尾部有足够的空间存放新增字符,并且知道字符串的"真实"长度.
5. 利用字符串重复出现的次数，编写一个方法，实现基本的字符串压缩功能，比如字符串aabcccccaaa会变成a2b1c5a3，若压缩后的字符串没有变短，则返回原来的字符串
6. 一张图像表示成NxN的矩阵，图像中每个像素是4个字节，写一个函数把图像旋转90度。 你能原地进行操作吗？(即不开辟额外的存储空间)
7. 编写一个算法, 若M × N矩阵中某个元素为0, 则将其所在的行与列清零
8. 假设你有一个isSubstring函数，可以检测一个字符串是否是另一个字符串的子串。给出字符串s1和s2，只使用一次isSubstring就能判断s2是否是s1的旋转字符串， 请写出代码。旋转字符串："waterbottle"是"erbottlewat"的旋转字符串。

## 链表
链表问题有时会难倒不少求职者,因为链表元素访问用时不定,而且往往涉及递归
### 快行指针技巧
快行指针指的是同时用两个指针来迭代访问链表,只不过其中一个比另一个超前一些。
### 递归问题
递归算法至少要占用 O( n) 空间,其中 n 为递归调用的层数。实际上,所有递归算法都可以转换成迭代法,只是后者实现起来可能要复杂得多。
### 面试题目
1. 编写代码,移除未排序链表中的重复结点。进阶如果不得使用临时缓冲区,该怎么解决?
2. 实现一个算法,找出单向链表中倒数第 k 个结点。
3. 实现一个算法,删除单向链表中间的某个结点,假定你只能访问该结点。
4. 编写代码,以给定值 x 为基准将链表分割成两部分,所有小于 x 的结点排在大于或等于x 的结点之前。
5. 给定两个用链表表示的整数,每个结点包含一个数位。这些数位是反向存放的,也就是个位排在链表首部。编写函数对这两个整数求和,并用链表形式返回结果。
6. 给定一个有环链表,实现一个算法返回环路的开头结点。
7. 编写一个函数,检查链表是否为回文。

## 栈与队列
### 实现一个栈
栈采用后进先出( LIFO) 顺序。
### 实现一个队列
队列采用先进先出( FIFO) 顺序。
### 面试题目
1. 描述如何只用一个数组来实现三个栈。
2. 请设计一个栈，除pop与push方法，还支持min方法，可返回栈元素中的最小值。pop、push和min三个方法的时间复杂度必须为O(1)。
3. 设想有一堆盘子，堆太高可能会倒下来。因此，在现实生活中，盘子堆到一定高度时，我们就会另外堆一堆盘子。请实现数据结构SetOfStacks，模拟这种行为。SetOfStacks应该由多个栈组成并且在前一个栈填满时新建一个栈。此外，SetOfStacks.push()和SetOfStacks.pop()应该与普通栈的操作方法相同（也就是说，pop()返回的值，应该跟只有一个栈时的情况一样）进阶：实现一个popAt(int index)方法，根据指定的子栈，执行 pop 操作。
4. 在经典问题汉诺塔中，有3根柱子及N个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自底向上从大到小依次套在第一根柱子上（即每一个盘子只能放在更大的盘子上面）。移动圆盘时有以下限制：
> 每次只能移动一个盘子  
盘子只能从柱子顶端滑出移到下一根柱子  
盘子只能叠在比它大的盘子上  
请运用栈，编写程序将所有盘子从第一根柱子移到最后一根柱子。
5. 实现一个MyQueue类，该类用两个栈来实现一个队列。
6. 编写程序，按升序对栈进行排序（即最大元素位于栈顶）。最多只能使用一个额外的栈存放临时数据，但不得将元素复制到别的数据结构中（如数组）。该栈支持如下操作：push、pop、peek和isEmpty。
7. 有家动物收容所只收容狗与猫，且严格遵守“先进先出”的原则。在收养该收容所的动物时，收养人只能收养所有动物中“最老”（根据进入收容所的时间长短）的动物，或者，可以挑选猫或狗（同时必须收养此类动物中“最老”的）。换言之，收养人不能自由挑选想收养的对象。请创建适用于这个系统的数据结构，实现各种操作方法，比如enqueue、dequeueAny、dequeueDog和dequeueCat等。