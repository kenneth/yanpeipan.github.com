---
layout: post
title: "程序员面试金典"
description: ""
category: 
tags: []
---
{% include JB/setup %}

# 面试考题

1. 数据结构
* 数组与字符串
* 链表
* 栈与队列
* 树与图
2. 概念与算法
* 位操作
* 智力题
* 数学与概率
* 面向对象设计
* 递归和动态规划
* 扩展性与存储限制
* 排序与查找
* 测试
3. 知识类问题
* C和C++
* Java
* 数据库
* 线程与锁
4. 附加面试题
* 中等难度
* 高等难度

## 数组与字符串

数组问题与字符串问题往往是相通的。换句话说, 书中提到的数组问题也可能以字符串的形式出现，反之亦然。

### 哈希表
散列表（Hash table，也叫哈希表），是根据关键字（Key-value）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。

1. 链式哈希表
* 将数据存储在"桶"(bucket)中, 每个"桶"都是一个链表, 且链表的容量随着冲突的增加而增大.  
2. 开地址哈希表
* 将数据存储在表本身, 并通过各种探查方法来避免冲突问题.  
3. 用二叉查找树实现哈希表
* 搜索、插入、删除的复杂度等于树高, 期望O(log n),最坏O(n)（数列有序，树退化成线性表）.通常采取二叉链表作为二叉查找树的存储结构.
* 虽然二叉查找树的最坏效率是O(n),但它支持动态查询，且有很多改进版的二叉查找树可以使树高为O(log n),如SBT,AVL树，红黑树等。
4. 哈希函数


* 广泛运用DJBX33A (Daniel J. Bernstein, Times 33 with Addition)
    
        uint32_t time33(char const *str, int len) 
        {
            unsigned long  hash = 0; 
            for (int i = 0; i < len; i++) {
                    hash = hash *33 + (unsigned long) str[i]; 
            } 
            return hash; 
        }
        

* 另一个哈希函数, 改编自:<Compilers: Principles, Techniques, and Tools>

        unsigned int hashpjw(const void *key) {
          const char *ptr;
          unsigned int val;
        
          // Hash the key by performing a number of bit operations on it
          val = 0;
          ptr = key;
          while (*ptr != '\0') {
            unsigned int tmp;
            val = (val << 4) + (*ptr);
        
            if ((tmp = (val & 0xf0000000))) {
              val = val ^ (tmp >> 24);
              val = val ^ tmp;
            }
        
            ptr++;
          }
        
          // in practice , replace PRIME_TBLESIZ with the actual table size
          return val % PRIME_TBLESIZ;
        }

### ArrayList(动态数组)

按需动态调整大小的数组, 数据访问时间为O(1).

### StringBuffer

创建一个足以容纳所有字符串的数组, 等它拼接完成才将这些字符串转成一个字符串.

### 面试题目

1. 实现一个算法, 确定一个字符串的所有字符是否全都不同.即使不允许使用额外的数据结构,又该如何处理?
2. 用C或C实现void reverse( char* str)函数, 即反转一个null结尾的字符.
3. 给定两个字符串, 请编写程序, 确定其中一个字符串的字符重新排列后,能否变成另一个字符串.
4. 编写一个方法, 将字符串中的空格全部替换为“% 20”。假定该字符串尾部有足够的空间存放新增字符,并且知道字符串的"真实"长度.
5. 利用字符串重复出现的次数，编写一个方法，实现基本的字符串压缩功能，比如字符串aabcccccaaa会变成a2b1c5a3，若压缩后的字符串没有变短，则返回原来的字符串
6. 一张图像表示成NxN的矩阵，图像中每个像素是4个字节，写一个函数把图像旋转90度。 你能原地进行操作吗？(即不开辟额外的存储空间)
7. 假设你有一个isSubstring函数，可以检测一个字符串是否是另一个字符串的子串。给出字符串s1和s2，只使用一次isSubstring就能判断s2是否是s1的旋转字符串， 请写出代码。旋转字符串："waterbottle"是"erbottlewat"的旋转字符串。
